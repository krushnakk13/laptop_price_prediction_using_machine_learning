# -*- coding: utf-8 -*-
"""ML_Laptop_Price_Prediction_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/162Xo1f5KtMy_exMOgSvhCjMX5lmxA5_y

# Laptop Price Predictor Case Study

A Laptop Price Predictor using machine learning helps make this easier. It can estimate the price of a laptop based on its features. This means users can enter details like the processor, RAM, storage, and screen size, and the model will predict how much the laptop might cost. This tool is useful for buyers to plan their budget and for sellers to set fair prices.

Objective:

To tackle this challenge, 'Laptop Price Predictor solution ' is conducting a machine learning case study aimed at developing a predictive model for estimating prices based on a comprehensive dataset that includes the following features: Company,TypeName,Inches,Cpu,Ram,Memory(HDD,SSD),GPU,Operating System
etc.,
"""



import pandas as pd
import numpy as np

df = pd.read_csv("/content/laptop_data.csv")

df.head()

df.shape

df.info()

"""# Data Cleaning"""

#check duplicate rows
df.duplicated().sum()

df.isna().sum()

df.drop(columns=['Unnamed: 0'],inplace=True)

df.head()

df['Ram'] = df['Ram'].str.replace('GB','')
df['Weight'] = df['Weight'].str.replace('kg','')

df.head()

df['Ram']= df['Ram'].astype('int32')
df['Weight'] = df['Weight'].astype('float32')

df.head()

df.info()

"""# EDA"""

import seaborn as sns
import matplotlib.pyplot as plt

sns.displot(df['Price'])

df['Company'].value_counts().plot(kind='bar')

import matplotlib.pyplot as plt
sns.barplot(x=df['Company'],y=df['Price'])
plt.xticks(rotation='vertical')
plt.show()

df['TypeName'].value_counts().plot(kind='bar')

sns.barplot(x=df['TypeName'],y=df['Price'])
plt.xticks(rotation='vertical')
plt.show()

sns.scatterplot(x=df['Inches'],y=df['Price'])

df['ScreenResolution'].value_counts()

df['Touchscreen'] = df['ScreenResolution'].apply(lambda x:1 if 'Touchscreen' in x else 0)

df.sample(5)

df['Touchscreen'].value_counts().plot(kind='bar')

sns.barplot(x=df['Touchscreen'],y=df['Price'])

df['Ips'] = df['ScreenResolution'].apply(lambda x:1 if 'IPS' in x else 0)

df.head()

df['Ips'].value_counts().plot(kind='bar')

sns.barplot(x=df['Ips'],y=df['Price'])

new = df['ScreenResolution'].str.split('x',n=1,expand=True)

df['X_res'] = new[0]
df['Y_res'] = new[1]

df.sample(5)

df['X_res'] = df['X_res'].str.replace(',','').str.findall(r'(\d+\.?\d+)').apply(lambda x:x[0])

df.head()

df['X_res'] = df['X_res'].astype('int')
df['Y_res'] = df['Y_res'].astype('int')

df.info()

df['ppi'] = (((df['X_res']**2) + (df['Y_res']**2))**0.5/df['Inches']).astype('float')

df.drop(columns=['ScreenResolution'],inplace=True)

df.head()

df.drop(columns=['Inches','X_res','Y_res'],inplace=True)

df.head()

df['Cpu'].value_counts()

df['Cpu Name'] = df['Cpu'].apply(lambda x:" ".join(x.split()[0:3]))

df.head()

def fetch_processor(text):
  if text == 'Intel Core i5' or text == 'Intel Core i7' or text == 'Intel Core i3':
    return text
  else:
    if text.split()[0]== 'Intel':
      return 'Other Intel Processor'
    else:
      return 'AMD Processor'

df['Cpu_brand'] = df['Cpu Name'].apply(fetch_processor)

df.head()

df['Cpu_brand'].value_counts().plot(kind='bar')

sns.barplot(x=df['Cpu_brand'],y=df['Price'])
plt.xticks(rotation='vertical')

df.drop(columns=['Cpu','Cpu Name'],inplace=True)

df.head()

df['Ram'].value_counts().plot(kind='bar')

sns.barplot(x = df['Ram'],y=df['Price'])
plt.xticks(rotation='vertical')
plt.show()

df['Memory'].value_counts()

df['Memory'] = df['Memory'].astype(str).replace('\.0', '', regex=True)
df['Memory'] = df['Memory'].str.replace('GB', '')
df['Memory'] = df['Memory'].str.replace('TB', '000')
new = df['Memory'].str.split('+', n = 1,expand = True)

df['first']=new[0]
df['first']=df['first'].str.strip()

df['second']= new[1]

df['Layer1HDD'] = df['first'].apply(lambda x: 1 if "HDD" in x else 0)
df['Layer1SSD'] = df['first'].apply(lambda x: 1 if "SSD" in x else 0)
df['Layer1Hybrid'] = df['first'].apply(lambda x: 1 if "Hybrid" in x else 0)
df['Layer1Flash_Storage'] = df['first'].apply(lambda x: 1 if "Flash Storage" in x else 0)

df['first']=df['first'].str.replace(r'\D', '',regex=True)

df['second'].fillna('0', inplace = True)

df['Layer2HDD'] = df['second'].apply(lambda x: 1 if "HDD" in x else 0)
df['Layer2SSD'] = df['second'].apply(lambda x: 1 if "SSD" in x else 0)
df['Layer2Hybrid'] = df['second'].apply(lambda x: 1 if "Hybrid" in x else 0)
df['Layer2Flash_Storage'] = df['second'].apply(lambda x: 1 if "Flash Storage" in x else 0)

df['second'] = df['second'].str.replace(r'\D', '',regex=True)

df['first'] = pd.to_numeric(df['first'].str.replace(r'\D', ''), errors='coerce').fillna(0).astype(int)
df['second']= df['second'].astype(int)

df['HDD']=(df['first']*df['Layer1HDD']+df['second']*df['Layer2HDD'])
df['SSD']=(df['first']*df['Layer1SSD']+df['second']*df['Layer2SSD'])
df['Hybrid']=(df['first']*df['Layer1Hybrid']+df['second']*df['Layer2Hybrid'])
df['Flash_Storage']=(df['first']*df['Layer1Flash_Storage']+df['second']*df['Layer2Flash_Storage'])

df.drop(columns=['first', 'second', 'Layer1HDD', 'Layer1SSD', 'Layer1Hybrid',
                 'Layer1Flash_Storage', 'Layer2HDD', 'Layer2SSD', 'Layer2Hybrid',
                 'Layer2Flash_Storage'], inplace=True)

df.head()

df.drop(columns=['Memory'],inplace=True)

df.head()

df.drop(columns=['Hybrid','Flash_Storage'],inplace=True)

df.head()

df['Gpu'].value_counts()

df['Gpu_brand'] = df['Gpu'].apply(lambda x:x.split()[0])

df.head()

df['Gpu_brand'].value_counts()

df = df[df['Gpu_brand'] != 'ARM']

df['Gpu_brand'].value_counts()

sns.barplot(x = df['Gpu_brand'],y=df['Price'],estimator=np.median)
plt.xticks(rotation='vertical')
plt.show()

df.drop(columns=['Gpu'],inplace=True)

df.head()

df['OpSys'].value_counts()

sns.barplot(x=df['OpSys'],y=df['Price'])
plt.xticks(rotation='vertical')
plt.show()

def cat_os(inp):
  if inp == 'Windows 10' or inp == 'Windows 7' or inp == 'Windows 10 s':
    return 'Windows'
  elif inp == 'macOS' or inp == 'Mac OS X':
    return 'Mac'
  else:
    return 'Others/No OS/Linux'

df['os'] = df['OpSys'].apply(cat_os)

df.head()

df.drop(columns=['OpSys'],inplace=True)

sns.barplot(x=df['os'],y=df['Price'])
plt.xticks(rotation='vertical')
plt.show()

sns.displot(df['Weight'])

sns.scatterplot(x=df['Weight'],y=df['Price'])

sns.heatmap(df.select_dtypes(include=np.number).corr())

sns.displot(np.log(df['Price']))

X = df.drop(columns=['Price'])
Y = np.log(df['Price'])

X

Y

from sklearn.model_selection import train_test_split
X_train,X_test,Y_train,Y_test = train_test_split(X,Y,test_size=0.15,random_state=2)

X_train

from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder
from sklearn.metrics import r2_score,mean_absolute_error

from sklearn.linear_model import LinearRegression
from sklearn.neighbors import KNeighborsRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor,GradientBoostingRegressor,AdaBoostRegressor
from sklearn.svm import SVR
from xgboost import XGBRegressor

"""# **Linear Regression**"""

step1  = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,7,10,11])
],remainder='passthrough')



step2 = LinearRegression()

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,Y_train)

y_pred = pipe.predict(X_test)


print('R2 score',r2_score(Y_test,y_pred))
print('MAE',mean_absolute_error(Y_test,y_pred))

"""# **KNN**"""

step1  = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,7,10,11])
],remainder='passthrough')



step2 = KNeighborsRegressor(n_neighbors=3)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,Y_train)

y_pred = pipe.predict(X_test)


print('R2 score',r2_score(Y_test,y_pred))
print('MAE',mean_absolute_error(Y_test,y_pred))

"""# **Decision Tree**"""

step1  = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,7,10,11])
],remainder='passthrough')



step2 = DecisionTreeRegressor(max_depth=8)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,Y_train)

y_pred = pipe.predict(X_test)


print('R2 score',r2_score(Y_test,y_pred))
print('MAE',mean_absolute_error(Y_test,y_pred))

"""# **SVM**"""

step1  = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,7,10,11])
],remainder='passthrough')



step2 = SVR(kernel='rbf',C=10000,epsilon=0.1)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,Y_train)

y_pred = pipe.predict(X_test)


print('R2 score',r2_score(Y_test,y_pred))
print('MAE',mean_absolute_error(Y_test,y_pred))

"""# **RandomForest**"""

step1  = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,7,10,11])
],remainder='passthrough')



step2 = RandomForestRegressor(n_estimators=100,
                              random_state=2,
                              max_samples=0.5,
                              max_features=0.75,
                              max_depth=15)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,Y_train)

y_pred = pipe.predict(X_test)


print('R2 score',r2_score(Y_test,y_pred))
print('MAE',mean_absolute_error(Y_test,y_pred))

"""# **AdaBoost**"""

step1  = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,7,10,11])
],remainder='passthrough')



step2 = AdaBoostRegressor(n_estimators=15,learning_rate=1.0)


pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,Y_train)

y_pred = pipe.predict(X_test)


print('R2 score',r2_score(Y_test,y_pred))
print('MAE',mean_absolute_error(Y_test,y_pred))

"""# **Gradient Boost**"""

step1  = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,7,10,11])
],remainder='passthrough')



step2 = RandomForestRegressor(n_estimators=500)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,Y_train)

y_pred = pipe.predict(X_test)


print('R2 score',r2_score(Y_test,y_pred))
print('MAE',mean_absolute_error(Y_test,y_pred))

"""# **Expring the Model**"""

import pickle
pickle.dump(df,open('df.pkl','wb'))
pickle.dump(pipe,open('pipe.pkl','wb'))

!pip install gradio

!pip install streamlit

import gradio as gr
import streamlit as st
import pickle
import numpy as np
import math

#load your model and data
pipe = pickle.load(open('pipe.pkl','rb'))
df1 = pickle.load(open('df.pkl','rb'))

X_train.head(1)

def predict_price(Company,TypeName,Ram,Weight,Touchscreen,Ips,ppi,Cpu_brand,HDD,SSD,Gpu_brand,os):
  #ppi=None
  if Touchscreen=='Yes':
    Touchscreen=1
  else:
    Touchscreen=0

  if Ips=='Yes':
    Ips=1
  else:
    Ips=0

  #Resolution = st.selectbox('Screen Resolution',['1920x1080','1366x768','1600x900','3840x2160','3200x1800','2880x1800','2560x1600','2560x1440','2304x1440'])
  #X_res = int(Resolution.split('x')[0])
  #Y_res = int(Resolution.split('x')[1])
  #ppi = (((int(X_res)**2) + (int(Y_res)**2))**0.5)/screen_size
  query = np.array([Company,TypeName,Ram,Weight,Touchscreen,Ips,ppi,Cpu_brand,HDD,SSD,Gpu_brand,os])
  query = query.reshape(1,12)
  price = pipe.predict(query)[0]
  return math.exp(price)


import gradio as gr
# Define the inputs and outputs for the Gradio interface
inputs = [
    gr.Dropdown(choices=df1['Company'].unique().tolist(), label="Company"),
    gr.Dropdown(choices=df1['TypeName'].unique().tolist(), label="TypeName"),
    gr.Dropdown(choices=df1['Ram'].unique().tolist(), label="Ram"),
    gr.Slider(minimum=df1['Weight'].min(), maximum=df1['Weight'].max(), value=df1['Weight'].mean(), label="Weight"),
    gr.Radio(['No','Yes'],label='TouchScreen'),
    gr.Radio(['No','Yes'],label='IPS'),
    gr.Number(label="ppi"),
    gr.Dropdown(choices=df1['Cpu_brand'].unique().tolist(), label="Cpu"),
    gr.Number(label="HDD"),
    gr.Number(label="SSD"),
    gr.Dropdown(choices=df1['Gpu_brand'].unique().tolist(), label="Gpu"),
    gr.Dropdown(choices=df1['os'].unique().tolist(), label="OS")
]

outputs = gr.Textbox(label='Predicted Price')
# Create and launch the Gradio interface
gr.Interface(fn=predict_price, inputs=inputs, outputs=outputs, title='Laptop Price Prediction').launch(debug=True)





